# GeneratedField in Django 5 - New Django Model Field!

## Key Concepts

- **Generated Field:** A model field introduced in Django 5 that creates **generated columns** in the database table.
- **Generated Columns:** Columns whose values are always computed or derived from the values stored in other columns of the same table.
  - **Example:** A `full_name` column generated by concatenating `first_name` and `last_name`.
- **Database Management:** The database itself manages and updates the values of generated columns.
- **`GENERATED ALWAYS` SQL Syntax:** Django uses this SQL syntax to define generated columns.
- **Output Dependency:** The output of a generated field is based on the values of other fields in the model and their corresponding database columns.
- **Types of Generated Columns:**
  - **Stored:** The generated value is computed when data is inserted or updated and occupies storage space like a regular column. This is similar to a **materialized view** in relational databases.
  - **Virtual:** The generated value is computed when the column is read and occupies no storage space. This is similar to a **view** in relational databases.
- **`db_persist` Parameter:** This parameter in `GeneratedField` determines whether the database column should occupy storage.
  - `db_persist=True`: Creates a stored generated column.
  - `db_persist=False`: Creates a virtual generated column.
- **Database Support Caveats:**
  - **PostgreSQL:** Only supports persisted (stored) generated columns.
  - **Oracle:** Only supports virtual generated columns.
  - **SQLite:** Supports both persisted and virtual generated columns.
- **Accessing Updated Generated Values:** After calling `model.save()`, you need to call `model.refresh_from_db()` to reload the object from the database and access the updated value of a generated column because the computation happens at the database level.
- **Efficiency:** Using generated columns can be more efficient for frequently accessed computed values, as the calculation is done at the database level rather than in the Python application layer.

## Examples

### 1. Calculating Profit in the `Sale` Model

- We define a `Sale` model with `income` and `expenditure` fields and add a `profit` generated field.

```python
from django.db import models
from django.db.models import F

class Sale(models.Model):
    income = models.DecimalField(max_digits=10, decimal_places=2)
    expenditure = models.DecimalField(max_digits=10, decimal_places=2)
    profit = models.GeneratedField(
        expression=F('income') - F('expenditure'),
        output_field=models.DecimalField(max_digits=10, decimal_places=2),
        db_persist=True,
    )

    def __str__(self):
        return f"Sale with income: {self.income}, expenditure: {self.expenditure}, profit: {self.profit}"
```

> [!TIP]
> To view the SQL statements after migrations, can use the command `python manage.py sqlmigrate <app_name> <migration_filename>`. For example `python manage.py sqlmigrate core 0014_sale_profit`

- Running migrations creates the `profit` column in the database. The SQL generated for this (in SQLite) looks like this:

```sql
CREATE TABLE new_core_sale (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    income NUMERIC NOT NULL,
    expenditure NUMERIC NOT NULL,
    profit NUMERIC GENERATED ALWAYS AS (income - expenditure) STORED NOT NULL
);
INSERT INTO new_core_sale (id, income, expenditure) SELECT id, income, expenditure FROM core_sale;
DROP TABLE core_sale;
ALTER TABLE new_core_sale RENAME TO core_sale;
```

- We can query the `profit` field directly like any other field:

```python
from core.models import Sale

first_sale = Sale.objects.first()
if first_sale:
    print(f"Sale Profit (from generated field): {first_sale.profit}")
    print(f"Sale Profit (calculated in Python): {first_sale.income - first_sale.expenditure}")
```

- We can order the sales by the generated `profit` field:

```python
max_profit_sale = Sale.objects.order_by('-profit').first()
if max_profit_sale:
    print(f"Sale with maximum profit: {max_profit_sale}")
```

- We can also aggregate based on the generated field:

```python
from django.db.models import Max

max_profit = Sale.objects.aggregate(Max('profit'))
print(f"Maximum profit across all sales: {max_profit}")
```

### 2. Calculating Suggested Tip with a Conditional Expression

- We add a `suggested_tip` generated field to the `Sale` model using a conditional (`Case` and `When`) expression:

```python
from django.db import models
from django.db.models import F, Case, When, Value

class Sale(models.Model):
    # ... (income and expenditure fields as before)
    profit = models.GeneratedField(
        expression=F('income') - F('expenditure'),
        output_field=models.DecimalField(max_digits=10, decimal_places=2),
        db_persist=True,
    )
    suggested_tip = models.GeneratedField(  # type: ignore
        expression=Case(
            When(income__gte=10, then=models.F('income') * 0.2),
            default=Value(0),
            output_field=models.DecimalField(max_digits=8, decimal_places=2),
        ),
        output_field=models.DecimalField(max_digits=8, decimal_places=2),
        db_persist=True
    )

    def __str__(self):
        return f"Sale with income: {self.income}, expenditure: {self.expenditure}, profit: {self.profit}, suggested tip: {self.suggested_tip}"
```

- Querying sales will now include the computed `suggested_tip`:

```python
from core.models import Sale

first_sale = Sale.objects.first()
if first_sale:
    print(f"Sale Income: {first_sale.income}, Suggested Tip: {first_sale.suggested_tip}")

low_income_sale = Sale.objects.filter(income__lt=10).first()
if low_income_sale:
    print(f"Sale Income: {low_income_sale.income}, Suggested Tip: {low_income_sale.suggested_tip}")
```

### 3. Calculating Event Duration

- We create a new `Event` model with `start_date` and `end_date` and a `duration` generated field:

```python
from django.db import models
from django.utils import timezone
from django.db.models import F

class Event(models.Model):
    name = models.CharField(max_length=255)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    duration = models.GeneratedField(
        expression=F('end_date') - F('start_date'),
        output_field=models.DurationField(),
        db_persist=True,
    )

    def __str__(self):
        return self.name

    @property
    def duration_in_days(self):
        return self.duration.days
```

- We can create some test events:

```python
from core.models import Event
from django.utils import timezone
from datetime import timedelta

for i in range(1, 6):
    Event.objects.create(
        name=f"Event {i}",
        start_date=timezone.now() - timezone.timedelta(days=i),
        end_date=timezone.now()
    )

print(f"Number of events created: {Event.objects.count()}")
```

- Querying the events will show the computed `duration`:

```python
from core.models import Event

for event in Event.objects.all():
    print(f"{event.name} Duration: {event.duration}, Duration in Days (property): {event.duration_in_days}")
```
