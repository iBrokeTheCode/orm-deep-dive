# Django Multiple Databases, inspectdb, and Database Routers

## Key Concepts

- **Using Multiple Databases:** Django allows connecting to and interacting with more than one database in a single application.
- **Common Use Cases:**
  - Integrating with **legacy systems**.
  - Pulling data from **external sources** like remote databases (e.g., Oracle).
  - Separating **read and write operations** across different databases.
  - Integrating with data from **third-party vendors**.
- **Defining Multiple Database Connections:** Multiple databases are configured in the `DATABASES` setting within your Django project's `settings.py` file. The `DATABASES` setting is a dictionary where each key represents a database alias (e.g., `default`, `course_db`) and the value is a dictionary containing connection parameters like `ENGINE` and `NAME`.
- **`inspectdb` Management Command:** This Django management command **autogenerates Django models by introspecting an existing database**. This is particularly useful when integrating with legacy databases.
- **`managed = False` in Models:** When a model is generated using `inspectdb` against an existing table, Django automatically sets `managed = False` in the model's `Meta` class. This tells Django that it **should not create, modify, or delete the corresponding database table** during migrations or other management commands, as the table is managed externally.
- **Database Routers:** Database routers provide **fine-grained control over which database is used for read and write operations** for specific models or applications. You can define rules to direct database traffic based on the app label of the model.
- **Data Synchronization:** When needing to create relationships (like foreign keys) between models residing in different databases, you typically need to **synchronize data** from the external database into your Django application's main database. This can be done using scheduled tasks (e.g., with Celery) to periodically copy data.

## Examples and Code

### 1. Defining Multiple Databases in `settings.py`

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    },
    'course_db': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'courses.sqlite3',
    }
}
```

This configuration defines two SQLite databases: `default` and `course_db`.

### 2. Creating a Simple Model (`Student`) in the `core` app (`core/models.py`)

```python
from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=200)

    def __str__(self):
        return self.name
```

After creating this model, you would run `python manage.py makemigrations core` and `python manage.py migrate` to create the corresponding table in the `default` database.

### 3. Creating a `courses` App and Autogenerating Models using `inspectdb`

```bash
python manage.py startapp courses
```

Add `'courses'` to `INSTALLED_APPS` in `settings.py`.

Then, run `inspectdb` to generate models from the `courses_db`:

```bash
python manage.py inspectdb --database=course_db > courses/models.py
```

This command introspects the `courses.sqlite3` database and writes the generated models into `courses/models.py`.

### 4. Example of an Autogenerated `Course` Model (`courses/models.py`)

```python
# This is an auto-generated Django model module.
# You'll have to do the following manually to clean this up:
#   * Rearrange models' order
#   * Make sure each model has one field with primary_key=True
#   * Make sure each ForeignKey and OneToOneField has `on_delete` set to the desired behavior
#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table
# Feel free to rename the models, but don't rename db_table values or field names.
from django.db import models

class CoursesCourse(models.Model):
    # Field from the database table
    # ...
    class Meta:
        db_table = 'course'
        managed = False
```

Note the `managed = False` attribute, indicating Django will not manage this table. The model name might be automatically pluralized based on the app name.

### 5. Accessing Data from the Second Database in a View (`core/views.py`)

```python
from django.shortcuts import render
from core.models import Student
from courses.models import Course

def index(request):
    students = Student.objects.all()
    courses = CoursesCourse.objects.all().using('course_db')
    context = {'students': students, 'courses': courses}
    return render(request, 'index.html', context)
```

The `.using('course_db')` method specifies that the query should be executed against the database with the alias `course_db`.

### 6. Creating a Custom Database Router (`core/db_router.py`)

```python
class DBRouter:
    """A router to control all database operations on models in the core and courses applications."""

    def db_for_read(self, model, **hints):
        """Attempts to read core models go to default.
        Attempts to read courses models go to course_db.
        """
        if model._meta.app_label == 'core':
            return 'default'
        elif model._meta.app_label == 'courses':
            return 'course_db'
        return None

    def db_for_write(self, model, **hints):
        """Attempts to write core models go to default.
        Attempts to write courses models go to course_db.
        """
        if model._meta.app_label == 'core':
            return 'default'
        elif model._meta.app_label == 'courses':
            return 'course_db'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """Allow relations if they are in the same database."""
        if obj1._state.db == obj2._state.db:
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """Make sure the core and courses apps only appear in their specified database."""
        if app_label == 'core':
            return db == 'default'
        elif app_label == 'courses':
            return db == 'course_db'
        return None
```

This router class defines how read and write operations should be directed based on the model's app label.

### 7. Registering the Database Router in `settings.py`

```python
DATABASE_ROUTERS = ['core.db_router.DBRouter']
```

This setting tells Django to use the `DBRouter` class defined in `core/db_router.py` for determining which database to use. After this, in `core/views.py`, you could simply use:

```python
courses = CoursesCourse.objects.all()
```

Django will automatically route the query to the `course_db` based on the router configuration.

### 8. Attempting to Create a ForeignKey Across Databases (`core/models.py`)

```python
from django.db import models
# Assuming CoursesCourse is imported

class Student(models.Model):
    name = models.CharField(max_length=200)
    course = models.ForeignKey(CoursesCourse, on_delete=models.SET_NULL, null=True) # This will cause issues

    def __str__(self):
        return self.name
```

Attempting to create a foreign key between `Student` (in the `default` database) and `CoursesCourse` (in `course_db`) will lead to errors because **foreign key constraints typically require tables to be in the same database**. Django's database router prevents this by default.

### 9. Creating a Local Model for Synchronization (`core/models.py`)

```python
from django.db import models

class LocalCourse(models.Model):
    name = models.CharField(max_length=200)

    def __str__(self):
        return self.name
```

This model will reside in the `default` database and will be used to store a local copy of the course data.

### 10. Creating a Django Management Command for Synchronization (`core/management/commands/sync_courses.py`)

**Initial Implementation (using the unmanaged `CoursesCourse` model):**

```python
from django.core.management.base import BaseCommand
from courses.models import Course
from core.models import LocalCourse

class Command(BaseCommand):
    help = 'Synchronizes courses from the external database to the local database'

    def handle(self, *args, **options):
        # external_courses = Course.objects.using('course_db').all()
        external_courses = Course.objects.all()
        for course in external_courses:
            LocalCourse.objects.update_or_create(
                pk=course.id,
                defaults={'name': course.name}
            )
        self.stdout.write(self.style.SUCCESS('Successfully synchronized courses'))
```

This command fetches courses from the `course_db` and creates or updates corresponding `LocalCourse` objects in the `default` database.

**Updated Implementation (using direct SQL queries):**

```python
from django.core.management.base import BaseCommand
from django.db import connections
from core.models import LocalCourse

class Command(BaseCommand):
    help = 'Synchronizes courses from the external database to the local database using SQL'

    def handle(self, *args, **options):
        with connections['course_db'].cursor() as cursor:
            cursor.execute("SELECT id, name FROM courses_course")
            rows = cursor.fetchall()
            for row in rows:
                course_id, course_name = row
                LocalCourse.objects.update_or_create(
                    pk=course_id,
                    defaults={'name': course_name}
                )
        self.stdout.write(self.style.SUCCESS('Successfully synchronized courses using SQL'))
```

This version directly executes an SQL query against the `course_db` to fetch the course data.

You would run this command using `python manage.py sync_courses`. This command could be scheduled to run periodically to keep the local data in sync with the external database.

By synchronizing the data into the `LocalCourse` model in the `default` database, you can now create a foreign key relationship in the `Student` model:

```python
from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=200)
    local_course = models.ForeignKey(LocalCourse, on_delete=models.SET_NULL, null=True)

    def __str__(self):
        return self.name
```

This allows creating relations between students and courses within the same (`default`) database
